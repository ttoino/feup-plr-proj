\documentclass[conference]{IEEEtran}

%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{pbalance} % for balancing the last page
\usepackage{enumitem} % for enumerated lists that can continue numbering
\usepackage{soul} % for underlining text with wrapping
\usepackage[htt]{hyphenat} % for text hyphenation and wrapping
\usepackage{pgfplots} % for the plot(s)

\pgfplotsset{compat=1.18}



\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\def\NOIMPL#1{\ul{#1} {\color{blue}[NOT IMPLEMENTED]\color{black}}}
\def\CONFIRM#1{\ul{#1} {\color{red}[CONFIRM]\color{black}}}
\def\CONFIRMIF[#1]#2{\ul{#2} {\color{red}[CONFIRM IF #1]\color{black}}}

\def\constraint#1{\vspace{4pt} {#1}}

\begin{document}

\title{
    Creating Optimized Schedules for Pharmacy Workers: a CLP-based approach \\
    % {
    %     \footnotesize A CLP-based approach
    % }
}

\author{
    \IEEEauthorblockN{João Pereira}
    \IEEEauthorblockA{
        \textit{Faculdade de Engenharia} \\
        \textit{Universidade do Porto} \\
        Porto, Portugal \\
        up202007145@up.pt
    }
\and
    \IEEEauthorblockN{André Lima}
    \IEEEauthorblockA{
        \textit{Faculdade de Engenharia} \\
        \textit{Universidade do Porto} \\
        Porto, Portugal \\
        up202008169@up.pt
    }
}

\maketitle

\begin{abstract}

The scheduling of workers is a common problem in many industries.
In the pharmacy industry, scheduling is usually done by hand and heeding to the preference of individual workers becomes a complex task, even at smaller scales. Furthermore, ensuring that schedules are fair and that the workload is evenly distributed among workers is a challenging task.
This paper presents a Constraint Logic Programming (CLP) based approach to create optimized schedules for pharmacy workers. The proposed approach uses a CLP solver to find the optimal schedule for a given set of workers. The performance of the proposed approach is evaluated using a real-world dataset of pharmacy workers. The results show that the proposed approach can create optimized schedules that meet the preferences of individual workers.

\end{abstract}

\begin{IEEEkeywords}
scheduling, optimization, clp, pharmacy
\end{IEEEkeywords}

\section{Introduction}

In some industries, scheduling of workers is very easy: all workers come in at the same time and they all leave at the same time.
However, in the pharmacy industry, scheduling can become a complex task, especially for smaller pharmacies, where the number of workers is reduced and schedules are adapted to meet the preferences of the workers.

With that in mind, a pharmacy in Portugal contacted us to create a scheduling system that would replace their current manual scheduling system. The new scheduling system should be faster and create better schedules when compared to the current system.
In section \ref{section:problem-statement}, the problem and the criteria used to compare schedules will be specified. In section \ref{section:proposed-model}, the proposed approach to model the problem will be presented, with a focus on developing an implementation for SICStus Prolog 4.9.0. In section \ref{section:results}, we will evaluate the model and discuss ways to improve its performance. In section \ref{section:further-work}, ideas for further work will be presented. Finally, in section \ref{section:conclusion}, the conclusions of this paper will be presented.

\section{Problem Statement}
\label{section:problem-statement}

The problem was initially presented as a very specific set of constraints.
After analyzing the problem, some constraints were generalized so that the system can better adapt to the pharmacy's future needs.

The resulting set of constraints can be summarized as follows:

\begin{enumerate}[start]
    \item {
        \label{constraint:domain}
        The pharmacy has 13 workers and 2 locations. 12 workers can work at the first location, but only 7 workers can work at the second location.
    }
    \item {
        \label{constraint:shifts}
        The first location has 7 daytime shifts and 1 nighttime shift. The second location has 2 daytime shifts.
    }
    \item {
        \label{constraint:variable-length-shifts}
        3 out of the 7 daytime shifts in the first location have variable length. These shifts are referred to as \textbf{variable-length shifts}.
    }
    \item {
        \label{constraint:overtime-shifts}
        Some shifts in the first location have longer duration, but don't give the workers overtime pay. These shifts will be referred to as \textbf{overtime shifts}. There must be 2 of these shifts each day.
    }
    \item {
        \label{constraint:late-shifts}
        Some shifts end later than others. These shifts will be referred to as \textbf{late shits}. Each worker cannot have more than 2 of these shifts each week.
    }
    \item {
        \label{constraint:nighttime-shift-implies-daytime-shift}
        If, on a given day, a worker is assigned to a nighttime shift, then they must also be assigned to a daytime shift on the same day. That shift must not be a late shift.
    }
    \item {
        \label{constraint:shift-incompatibilities}
        Workers cannot be assigned to shifts that are incompatible with their daily commitments. These commitments are known ahead of time and will be referred to as a worker's \textbf{shift incompatibilities}.
    }
    \item {
        \label{constraint:rotated-shifts}
        Some shifts have a "good" or "bad" reputation and a worker cannot be assigned more than once to each of these shifts. These shifts will be refered to as \textbf{rotated shifts}.
    }
    \item {
        \label{constraint:weekend-schedules-known-ahead-of-time}
        Weekend schedules are known ahead of time and don't need to be calculated.
    }
    \item {
        \label{constraint:absences-known-ahead-of-time}
        Some absences are known ahead of time. Every day, 4 workers need to be absent.
    }
\end{enumerate}

Furthermore, certain criteria make a schedule better than others. These criteria are:

\begin{enumerate}[resume]
    \item {
        \label{criterion:worker-preferences}
        Workers should have their preferences met. For example, if a worker prefers to start and end their shifts earlier, then they should be assigned to shifts that facilitate that, if possible.
    }
    \item {
        \label{criterion:nighttime-workers-prioritzation}
        If a worker is assigned to a night shift, their preferences should be prioritized in the daytime shift. Furthermore, in the following day, they should be assigned to an absense, whenever possible.
    }
    \item {
        \label{criterion:night-shifts-distribution}
        Nighttime shifts should be equally distributed among all workers.
    }
    \item {
        \label{criterion:rotated-shifts-distribution}
        Rotated shifts need to be equally distributed among all workers.
    }
    \item {
        \label{criterion:overtime-distribution}
        Overtime should be equally distributed among all workers.
    }
    \item {
        \label{criterion:absences-distribution}
        Absences that are not known ahead of time should be equally distributed among all workers.
    }
    \item {
        \label{criterion:worker-groups}
        Some workers go to the gym together and, thus, prefer to have similar schedules.
    }
\end{enumerate}

As it can be seen, this problem presents similarities to the \textit{nurses' problem}, which is a well known problem in the scheduling literature. However, this problem has some unique constraints, such as the fact that some shifts have variable length or that a pharmacist can be assigned to a daytime shift and a nighttime shift in the same day. Furthermore, this problem also presents some optimization elements, such as the equal distribution of overtime and absences.

\section{Proposed Model}
\label{section:proposed-model}

To approach this problem, a Constraint Logic Programming (CLP) based approach was used. CLP allows for the easy modeling of constraints and the optimization of a given objective function.
The proposed model was implemented using SICStus Prolog 4.7.1. 

The model can be divided into three main parts: the data structures used, the constraints that are imposed on the data structures and the optimization criteria used, and the objective function that is optimized.

\subsection{Data Structures}
\label{section:data-structures}

Regarding the data structures that were used, an approach similar to the one used in the \textit{nurses' problem} was used. That is two matrices were created, using the \texttt{setup\_domain\_and\_channeling/5} predicate:

\begin{itemize}
    \item {
        The \texttt{Day\_Worker\_Shift} matrix, where, for each day, each worker is assigned a shift. If a worker doesn't get assigned to a shift on that day, then the value assigned is 0.
        The domain for these values is \texttt{0..S}, where \texttt{S} is the number of shifts. For each day, the constraint \texttt{all\_distinct\_except\_0} is imposed, so that a shift is not assigned to more than one worker.
    }
    \item {
        The \texttt{Day\_Shift\_Worker} matrix, where, for each day, each shift is assigned a worker. If a shift doesn't get assigned to a worker on that day, then the value assigned is 0.
        The domain for these values is \texttt{0..W}, where \texttt{W} is the number of workers. For each day, the constraint \texttt{all\_distinct\_except\_0} is imposed, so that a worker is not assigned to more than one shift.
    }
\end{itemize}

After having these matrices set up, they need to be channeled, so that changes in one matrix are reflected in the other.
This is done by iterating over the matrices and applying \texttt{element} and \texttt{\#<=>} constraints. Regarding the \texttt{element} constraints, they are used because the values in \texttt{Day\_Worker\_Shift} matrix correspond to indices in the \texttt{Day\_Shift\_Worker} matrix. The same is true for the values in the \texttt{Day\_Shift\_Worker} matrix and the indices in the \texttt{Day\_Worker\_Shift} matrix. The \texttt{\#<=>} constraints are used to ensure the \texttt{element} constraints are only applied when the value used as index is different from 0.

Regarding the night shifts, using what was described above isn't enough, since the approach doesn't allow a worker to be assigned to a day and a night shift on the same day, as described in constraint \ref{constraint:nighttime-shift-implies-daytime-shift}.
To solve this, the night shifts have their own \texttt{Day\_Worker\_Shift} and \texttt{Day\_Shift\_Worker} matrices, named \texttt{Day\_Worker\_NightShift} and \texttt{Day\_NightShift\_Worker}, respectively.

\subsection{Constraints}
\label{section:constraints}

For each constraint that was described in section \ref{section:problem-statement}, a predicate was created to enforce it. How each predicate is implemented will be described in the following paragraphs.

Regarding constraints \ref{constraint:domain} and \ref{constraint:shifts}, they already already enforced by the domain of the matrices, as described in \ref{section:data-structures}.

\constraint {
    \subsubsection*{Variable-length shifts}
    In order to implement variable-length shifts, as described in constraint \ref{constraint:variable-length-shifts}, the concept of alternative shifts was introduced. Alternative shifts are shifts where only of them can exist in a given day of the week. A list of pairs of indices of shifts is defined to indicate which shifts represent different lengths of the same shift.
    To implement this constraint, the \texttt{setup\_alternative\_shifts/2} predicate was created. In it, for each day in the \texttt{Day\_Shift\_Worker} matrix, two sets of constraints are imposed: the first is a constraint that states that the number of shifts that have no workers assigned to them is equal to the number of alternative shift pairs, implemented using \texttt{count}; the second is that, for each pair of alternative shifts, exactly one of them must have a worker assigned, implemented using \texttt{Worker1 \#= 0 \#<=> Worker2 \#\textbackslash= 0}.
}

\constraint {
    \subsubsection*{Overtime shifts}
    To implement overtime shifts, as described in constraint \ref{constraint:overtime-shifts}, a list of indices of shifts that are considered to be overtime shifts is defined. This approach, combined with the one used for variable-length shifts, allows for only one of the alternative shifts to be considered an overtime shift, if needed. Furthermore, the total number of overtime shifts per day is defined.
    To implement this constraint, the \texttt{setup\_overtime\_shifts/3} predicate was created. In it, for each day in the \texttt{Day\_Worker\_Shift} matrix, constraints are imposed, using the \texttt{count} constraint, to determine how many times each overtime shift occurs in that day. The counts are then added, using the \texttt{sum} constraint, and the result is imposed to be equal to the daily limit of overtime shifts.
}

\constraint {
    \subsubsection*{Late shifts}
    To implement late shifts, as described in constraint \ref{constraint:late-shifts}, a list of indices of shifts that are considered to be late shifts is defined. Like with the overtime shifts, this allows for only one of the alternative shifts to be considered a late shift, if needed. Furthermore, the maximum number of late shifts per week per worker is defined.
    To implement this constraint, the \texttt{setup\_late\_shifts/3} predicate was created. In it, for each worker in the \texttt{Worker\_Day\_Shift} matrix (the transposed matrix of the \texttt{Day\_Worker\_Shift} matrix), constraints are imposed, using the \texttt{count} constraint, to determine how many times each late shift occurs in that week. The counts are then added, using the \texttt{sum} constraint, and the result is imposed to be less than or equal to the weekly limit of late shifts per worker.
}

\constraint {
    \subsubsection*{Nighttime shift implies an early daytime shift}
    To implement the constraint that assigning a nighttime shift implies an assignment of an daytime shift, as described in constraint \ref{constraint:nighttime-shift-implies-daytime-shift}, the \texttt{setup\_night\_shifts/2} predicate was created. In it, for each day in the \texttt{Day\_Worker\_Shift} and \texttt{Day\_Worker\_NightShift} matrices, constraints are imposed to ensure that, if a worker is assigned to a nighttime shift on a given day, then they must also be assigned to a daytime shift on the same day. This is implemented using the constraint \texttt{NightShift \#\textbackslash= 0 \#=> Shift \#\textbackslash= 0}. To ensure that the assigned daytime shift is an early shift, as described in the previously mentioned constraint, the \texttt{setup\_late\_night\_shifts/3} predicate was implemented. In it, for each day in the \texttt{Day\_Shift\_Worker} and \texttt{Day\_Worker\_NightShift} matrices, all late shifts are iterated over and, if a worker is assigned to a late shift during the day, then their nighttime shift is set to 0, using the \texttt{element} constraint.
}

\constraint {
    \subsubsection*{Shift incompatibilities}   
    To implement shift incompatibilities, as described in constraint \ref{constraint:shift-incompatibilities}, a list of shift incompatibilities is defined. This list contains, for each worker, a list of indices of shifts that are incompatible with their daily commitments.
    To implement this constraint, the \texttt{setup\_incompatible\_shifts/2} predicate was created. In it, for each day and each worker in the \texttt{Day\_Worker\_Shift} matrix, a constraint is imposed on every shift to ensure it is not equal to any of the incompatible shifts for that worker, using the \texttt{Shift \#\textbackslash= IncompatibleShift} constraint.
}

\constraint {
    \subsubsection*{Rotated shifts}
    To implement rotated shifts, as described in constraint \ref{constraint:rotated-shifts}, a list of indices of shifts that are considered to be rotated shifts is defined.
    To implement this constraint, the \texttt{setup\_rotated\_shifts/2} predicate was created. In it, for each shift in the rotated shifts list, a \texttt{all\_different\_except\_0} constraint is imposed on the corresponding list of workers that are assigned to that shift in each day, to ensure that no worker is assigned more than once to that rotated shift.
}

\constraint {
    \subsubsection*{Weekend schedules known ahead of time}   
    Since weekend schedules are known ahead of time and don't need to be calculated, as described in constraint \ref{constraint:weekend-schedules-known-ahead-of-time}, it was decided to only support generating schedules for weekdays.
}
    
\constraint {
    \subsubsection*{Absences that are known ahead of time}
    Some absences schedules are known ahead of time and don't need to be calculated, as described in constraint \ref{constraint:absences-known-ahead-of-time}. To implement this constraint, its implementation was made more general and, instead, there is support for setting any worker's schedule ahead of time (including 0 for absences).
    This was done using \texttt{maplist(eq\_list, Worker\_Day\_Shift, KnownShifts)} for daytime shifts, which ensures that every list inside \texttt{Worker\_Day\_Shift} - that is, a worker's weekly schedule - is equal to the corresponding list inside \texttt{KnownShifts}. The same is done for nighttime shifts.
    The constraint where 4 workers need to be absent every day was not implemented, since it is implicit in the problem domain: with 13 workers and 9 daytime shifts, 4 workers will be absent every day.
}

\subsection{Optimization criteria}
\label{section:optimization-criteria}

In addition to the constraints, several optimization criteria were implemented to improve the quality of the generated schedules. These criteria aim to meet worker preferences, distribute shifts fairly, and balance workloads.

Regarding the optimization criterion \ref{criterion:worker-groups}, it was not implemented, since it was considered to be a low priority criterion.

Some of the criteria specified below rely on a predicate called \texttt{score\_distances/2}. This predicate calculates the sum of absolute differences between all pairs of scores in the provided list, providing a measure of how evenly distributed a given score is among workers.

\constraint {
    \subsubsection*{Worker preferences}
    To implement worker preferences, as described in criterion \ref{criterion:worker-preferences}, two lists of preferred shifts are defined: one for daytime shifts and another for nighttime shifts. These lists contain, for each worker, a list with the indices of their preferred shifts.
    To implement this criterion, the \texttt{calculate\_preference\_scores/3} predicate was created. For each worker, it determines how many times they are assigned to a preferred shift throughout the week. These individual scores are returned by the predicate. This is done for both daytime and nighttime shifts separately.
}

\constraint {
    \subsubsection*{Prioritization of nighttime workers}
    To prioritize the preferences of workers assigned to night shifts, as described in criterion \ref{criterion:nighttime-workers-prioritzation}, the \texttt{calculate\_priority\_preference\_scores/4} predicate was implemented. This predicate, for each worker in the \texttt{Worker\_Day\_Shift} matrix, counts how many times they are assigned to nighttime shifts and to a preferred daytime shift in the same day. This is implemented using the \texttt{(NightShift \#\textbackslash= 0) \#/\textbackslash element(\_, PreferredShift, Shift)} predicate.
}

\constraint {
    \subsubsection*{Distribution of night shifts}
    To ensure an equal distribution of night shifts over multiple weeks, as described in criterion \ref{criterion:night-shifts-distribution}, a list with the previous night shift score for every worker is provided, that is, how many times they were assigned to a night shift in previous weeks.
    To implement this criterion, the \texttt{calculate\_night\_shift\_scores/3} predicate was implemented. In it, for each worker in the \texttt{Worker\_Day\_NightShift} matrix, their night shift score is incremented by 1 if they are assigned to a night shift, using the \texttt{Out \#= In + (NightShift \#\textbackslash= 0)} constraint, where \texttt{Out} and \texttt{In} are accumulators in a \texttt{fromto} iterator. In the end, the new night shift scores are returned by the predicate. \texttt{score\_distances/2} is used to calculate a measure of how balanced the values in the list are. The resulting value is then used as a score for the night shift distribution.
}

\constraint {
    \subsubsection*{Distribution of rotated shifts}
    To ensure an equal distribution of rotated shifts over multiple weeks, as described in criterion \ref{criterion:rotated-shifts-distribution}, a list with the previous rotated shift score for every worker and rotated shift is provided, that is, how many times they were assigned to that rotated shift in previous weeks. 
    To implement this criterion, the \texttt{calculate\_rotated\_shift\_scores/4} predicate was created. In it, for each worker in the \texttt{Worker\_Day\_Shift} matrix, and for each rotated shift, the number of times they are assigned to that rotated shift is determined, using the \texttt{count} constraint. This value is then added to that worker's previous rotated shift score to determine the new rotated shift score, for that shift. In the end, these new rotated shift scores are returned by the predicate. \texttt{score\_distances/2} is used to calculate a measure of how balanced the values in the matrix are. The resulting value is then used as a score for the rotated shifts distribution.
}


\constraint {
    \subsubsection*{Overtime distribution}
    To distribute overtime equally among workers over multiple weeks, as described in criterion \ref{criterion:overtime-distribution}, a list with the previous overtime shift score for every worker is provided, that is, how many times they were assigned to an overtime shift in previous weeks. 
    To implement this criterion, the \texttt{calculate\_overtime\_shift\_scores/4} predicate was implemented. In it, a procedure similar to the one used for rotated shift distribution is used, with the simplification that the counts for all overtime shifts are aggregated into a single count. The new overtime shift scores are returned by the predicate. \texttt{score\_distances/2} is used here as well to calculate a measure of how balanced the values in the list are. The resulting value is then used as a score for the overtime distribution.
}

\constraint {
    \subsubsection*{Absences distribution}
    To distribute absences equally among workers over multiple weeks, as described in criterion \ref{criterion:absences-distribution}, a list with the previous available absences for every worker is provided, that is, how many absences they can take in the following weeks.
    To implement this criterion, the \texttt{calculate\_absences/3} predicate was implemented. In it, a procedure similar to the one used for rotated shift and overtime shift distributions is used, with the difference that the absences taken by the worker are subtracted from their previous available absences. The new available absences is constrained to be greater than or equal to 0. The new available absences are returned by the predicate and passed on to \texttt{score\_distances/2} to calculate a measure of how balanced the values in the list are. The resulting value is then used as a score for the absences distribution.
}

\subsection{Objective Function}
\label{section:objective-function}

The objective function combines all the optimization criteria specified in section \ref{section:optimization-criteria} into a single score that represents the quality of the generated schedule. This score is calculated using the \texttt{Score} variable.

The objective function is divided into two main components.
The first is a maximization component (\texttt{MaxiScore}), which includes scores for:

\begin{itemize}
    \item Worker preferences
    \item Prioritization of nighttime workers
\end{itemize}

The second is a minimization component (\texttt{MiniScore}), which includes scores for:

\begin{itemize}
    \item Absences distribution 
    \item Rotated shifts distribution
    \item Overtime distribution
    \item Night shifts distribution
\end{itemize}

The final score is calculated as the difference between the maximization and minimization components: \texttt{Score \#= MaxiScore - MiniScore}. The objective function aims to maximize worker preferences and priority preferences while minimizing the differences in the distribution of absences, rotated shifts, overtime shifts, and night shifts. This balanced approach ensures that the generated schedule not only meets workers' preferences but also maintains fairness in the distribution of various shift types and workloads.

Finally, the \texttt{Score} variable is maximized using the  \texttt{maximize(Score)} search option, ensuring that the generated schedules have good quality according to the defined criteria and constraints.

\section{Results}
\label{section:results}

In order to determine the best search strategy for the model proposed in section \ref{section:proposed-model} and strategies to improve its performance even further, two sets experiments were conducted.

In each experiment, SICStus Prolog 4.9.0 was used. Two different sets of intial conditions were available: the "empty" input, where all inputs were set to their most general values, and the "known" input, where some shifts and absences were known ahead of time. Furthermore, the measured values were obtained by running the model a single time for each experiment. A timeout of 5 minutes was used since this system is meant to be used to help the user make scheduling decisions in real-time.

\subsection{Search Strategies Comparison}

The first series of experiments aimed to determine the best search strategy for the proposed model. The results of these experiments, as well as the list of 40 unique search strategies tested, are available in the appendix.

From the results, it can be seen that the most effective search strategy is "impact down", both with the "empty" and "known" inputs. This strategy was able to start generating the best schedules out of all the strategies tested within one second of the start of the search.

Regarding the "known" input, most strategies were initially able to generate good schedules, but only 3 strategies were able to generate significantly better schedules than those initially generated.

Another interesting observation is that, while performing these experiments, it was noticed that many of the search strategies were not producing any results. It was then noticed that putting the \texttt{Score} variable at the end of the search variables list produced much better results. This is likely due to the fact that the \texttt{Score} variable is not very relevant for assigning schedules, but rather for evaluating them. As such, it is better to have it at the end of the search variables list.

Finally, the \texttt{enum} option is not presented in the comparison, because results were very similar to the \texttt{step} search option. The \texttt{bisect} option was also not presented, because its performance was significantly worse than the other options.

\subsection{Global Constraints Comparison}

The second series of experiments aimed to determine if and how the performance of the model could be improved. In these experiments, some constraints were replaced by global constraints. Specifically, some chained additions were replaced by the \texttt{sum} constraint. Other similar improvements were also made. The "impact down" strategy was used for both measurements. The results of this experiment are available in the appendix.

From the results, it can be seen that replacing some constraints with global constraints improved performance significantly, especially up until the 40 seconds mark. After that point, the performance got worse when compared to the model before the changes. This is likely due to the fact that replacing some constraints with global constraints made the model change its search order, which made it harder to find better schedules after a certain point.

Overall, this change is positive for the proposed model, since it is designed to obtain the highest quality model in the shortest amount of time. It is also likely that introducing even more global constraints would help the model generate even better schedules in an even shorter amount of time. 

\section{Further Work}
\label{section:further-work}

The proposed model can be further improved in several ways. Some of the most promising improvements are listed in the following sections.

\subsection*{Replace more constraints with global constraints}

It was observed that replacing some constraints with global constraints improved the performance of the model. It is likely that replacing even more constraints with global constraints would further improve the performance of the model.

\subsection*{Refine objective function}

Refining the objective function could improve the quality of the generated schedules. For example, the weights of the different optimization criteria could be adjusted to better reflect the importance of each criterion.

\subsection*{Implement worker groups}

Implementing worker groups could improve the quality of the generated schedules. Worker groups could be used to ensure that workers with similar preferences are assigned similar schedules. Although this was considered a low priority criterion, it could still be beneficial to implement it.

\subsection*{Research if implementation of custom global constraints can improve performance}

It is likely that the performance of the model could be further improved by implementing custom global constraints. These constraints could be tailored to the specific requirements of the scheduling problem and could help the model find better schedules more efficiently.

\subsection*{Implement model in another solver}

One of the main reasons for choosing SICStus Prolog was its ease of use and the fact that it is a well-known solver for CLP problems. 
Implementing the model in another solver, such as CPLEX ILOG or OR-Tools, and comparing the performance could be beneficial. Different solvers have different strengths and weaknesses, and it is possible that another solver could find better schedules more efficiently.

\section{Conclusion}
\label{section:conclusion}

Concluding this paper, it can be seen that the proposed model is able to generate valid schedules that meet the preferences of individual workers. Although the model can still be improved, the results are very satisfactory and show that the proposed approach is a promising solution for the scheduling problem presented in section \ref{section:problem-statement}.

Although CLP is a very powerful tool for solving scheduling problems, it is not without its limitations. The main limitation of CLP is that it can be computationally expensive to find the optimal solution for large scheduling problems.
As such, strategies other than CLP may be needed to solve very large scheduling problems.

% \bibliographystyle{./IEEEtran}
% \bibliography{./IEEEabrv,./IEEEexample,./report}

\onecolumn
\appendix

\tikzset{
    % only marks,
    const plot,
}
\pgfplotsset{
    table/col sep=comma,
    % table/x=time,
    % table/y=score,
    domain=0:300000,
    xlabel=Time (ms),
    ylabel=Score,
    width=\textwidth,
    height=0.49\textwidth,
    legend style={
            cells={anchor=west},
            anchor=north,
            at={(0.5,-0.16)},
            legend columns=5,
        },
}

\begin{center}
    \begin{tikzpicture}
        \begin{semilogxaxis}[title=Search Strategies Comparison - Score over time with "empty" input]
            \addplot[color=red, mark=o] table {./results/empty/anti_first_fail-step-down-bab.csv};
            \addplot[color=red, mark=square] table {./results/empty/anti_first_fail-step-median-bab.csv};
            \addplot[color=red, mark=diamond] table {./results/empty/anti_first_fail-step-middle-bab.csv};
            % \addplot[color=red, mark=triangle] table {./results/empty/anti_first_fail-step-up-bab.csv};

            \addplot[color=green, mark=o] table {./results/empty/dom_w_deg-step-down-bab.csv};
            \addplot[color=green, mark=square] table {./results/empty/dom_w_deg-step-median-bab.csv};
            \addplot[color=green, mark=diamond] table {./results/empty/dom_w_deg-step-middle-bab.csv};
            \addplot[color=green, mark=triangle] table {./results/empty/dom_w_deg-step-up-bab.csv};

            % \addplot[color=blue, mark=o] table {./results/empty/first_fail-step-down-bab.csv};
            % \addplot[color=blue, mark=square] table {./results/empty/first_fail-step-median-bab.csv};
            \addplot[color=blue, mark=diamond] table {./results/empty/first_fail-step-middle-bab.csv};
            % \addplot[color=blue, mark=triangle] table {./results/empty/first_fail-step-up-bab.csv};

            \addplot[color=cyan, mark=o] table {./results/empty/impact-step-down-bab.csv};
            \addplot[color=cyan, mark=square] table {./results/empty/impact-step-median-bab.csv};
            \addplot[color=cyan, mark=diamond] table {./results/empty/impact-step-middle-bab.csv};
            \addplot[color=cyan, mark=triangle] table {./results/empty/impact-step-up-bab.csv};

            \addplot[color=magenta, mark=o] table {./results/empty/largest-step-down-bab.csv};
            \addplot[color=magenta, mark=square] table {./results/empty/largest-step-median-bab.csv};
            \addplot[color=magenta, mark=diamond] table {./results/empty/largest-step-middle-bab.csv};
            % \addplot[color=magenta, mark=triangle] table {./results/empty/largest-step-up-bab.csv};

            \addplot[color=yellow, mark=o] table {./results/empty/leftmost-step-down-bab.csv};
            \addplot[color=yellow, mark=square] table {./results/empty/leftmost-step-median-bab.csv};
            \addplot[color=yellow, mark=diamond] table {./results/empty/leftmost-step-middle-bab.csv};
            \addplot[color=yellow, mark=triangle] table {./results/empty/leftmost-step-up-bab.csv};

            \addplot[color=brown, mark=o] table {./results/empty/max_regret-step-down-bab.csv};
            \addplot[color=brown, mark=square] table {./results/empty/max_regret-step-median-bab.csv};
            \addplot[color=brown, mark=diamond] table {./results/empty/max_regret-step-middle-bab.csv};
            \addplot[color=brown, mark=triangle] table {./results/empty/max_regret-step-up-bab.csv};

            % \addplot[color=orange, mark=o] table {./results/empty/most_constrained-step-down-bab.csv};
            % \addplot[color=orange, mark=square] table {./results/empty/most_constrained-step-median-bab.csv};
            \addplot[color=orange, mark=diamond] table {./results/empty/most_constrained-step-middle-bab.csv};
            % \addplot[color=orange, mark=triangle] table {./results/empty/most_constrained-step-up-bab.csv};

            % \addplot[color=teal, mark=o] table {./results/empty/occurrence-step-down-bab.csv};
            % \addplot[color=teal, mark=square] table {./results/empty/occurrence-step-median-bab.csv};
            \addplot[color=teal, mark=diamond] table {./results/empty/occurrence-step-middle-bab.csv};
            \addplot[color=teal, mark=triangle] table {./results/empty/occurrence-step-up-bab.csv};

            \addplot[color=violet, mark=o] table {./results/empty/smallest-step-down-bab.csv};
            \addplot[color=violet, mark=square] table {./results/empty/smallest-step-median-bab.csv};
            \addplot[color=violet, mark=diamond] table {./results/empty/smallest-step-middle-bab.csv};
            % \addplot[color=violet, mark=triangle] table {./results/empty/smallest-step-up-bab.csv};
        \end{semilogxaxis}
    \end{tikzpicture}
\end{center}

\begin{center}
    \begin{tikzpicture}
        \begin{semilogxaxis}[title=Search Strategies Comparison - Score over time with "known" input]
            \addlegendimage{color=white, only marks}
            \addplot[color=red, mark=o] table {./results/known/anti_first_fail-step-down-bab.csv};
            % \addplot[color=red, mark=square] table {./results/known/anti_first_fail-step-median-bab.csv};
            \addlegendimage{color=red, mark=square}
            \addplot[color=red, mark=diamond] table {./results/known/anti_first_fail-step-middle-bab.csv};
            % \addplot[color=red, mark=triangle] table {./results/known/anti_first_fail-step-up-bab.csv};
            \addlegendimage{color=red, mark=triangle}

            \addlegendimage{color=white, only marks}
            \addplot[color=green, mark=o] table {./results/known/dom_w_deg-step-down-bab.csv};
            \addplot[color=green, mark=square] table {./results/known/dom_w_deg-step-median-bab.csv};
            \addplot[color=green, mark=diamond] table {./results/known/dom_w_deg-step-middle-bab.csv};
            \addplot[color=green, mark=triangle] table {./results/known/dom_w_deg-step-up-bab.csv};

            \addlegendimage{color=white, only marks}
            % \addplot[color=blue, mark=o] table {./results/known/first_fail-step-down-bab.csv};
            \addlegendimage{color=blue, mark=o}
            \addplot[color=blue, mark=square] table {./results/known/first_fail-step-median-bab.csv};
            \addplot[color=blue, mark=diamond] table {./results/known/first_fail-step-middle-bab.csv};
            % \addplot[color=blue, mark=triangle] table {./results/known/first_fail-step-up-bab.csv};
            \addlegendimage{color=blue, mark=triangle}

            \addlegendimage{color=white, only marks}
            \addplot[color=cyan, mark=o] table {./results/known/impact-step-down-bab.csv};
            \addplot[color=cyan, mark=square] table {./results/known/impact-step-median-bab.csv};
            \addplot[color=cyan, mark=diamond] table {./results/known/impact-step-middle-bab.csv};
            \addplot[color=cyan, mark=triangle] table {./results/known/impact-step-up-bab.csv};

            \addlegendimage{color=white, only marks}
            \addplot[color=magenta, mark=o] table {./results/known/largest-step-down-bab.csv};
            \addplot[color=magenta, mark=square] table {./results/known/largest-step-median-bab.csv};
            \addplot[color=magenta, mark=diamond] table {./results/known/largest-step-middle-bab.csv};
            % \addplot[color=magenta, mark=triangle] table {./results/known/largest-step-up-bab.csv};
            \addlegendimage{color=magenta, mark=triangle}

            \addlegendimage{color=white, only marks}
            \addplot[color=yellow, mark=o] table {./results/known/leftmost-step-down-bab.csv};
            \addplot[color=yellow, mark=square] table {./results/known/leftmost-step-median-bab.csv};
            \addplot[color=yellow, mark=diamond] table {./results/known/leftmost-step-middle-bab.csv};
            \addplot[color=yellow, mark=triangle] table {./results/known/leftmost-step-up-bab.csv};

            \addlegendimage{color=white, only marks}
            \addplot[color=brown, mark=o] table {./results/known/max_regret-step-down-bab.csv};
            \addplot[color=brown, mark=square] table {./results/known/max_regret-step-median-bab.csv};
            \addplot[color=brown, mark=diamond] table {./results/known/max_regret-step-middle-bab.csv};
            % \addplot[color=brown, mark=triangle] table {./results/known/max_regret-step-up-bab.csv};
            \addlegendimage{color=brown, mark=triangle}

            \addlegendimage{color=white, only marks}
            % \addplot[color=orange, mark=o] table {./results/known/most_constrained-step-down-bab.csv};
            \addlegendimage{color=orange, mark=o}
            \addplot[color=orange, mark=square] table {./results/known/most_constrained-step-median-bab.csv};
            \addplot[color=orange, mark=diamond] table {./results/known/most_constrained-step-middle-bab.csv};
            % \addplot[color=orange, mark=triangle] table {./results/known/most_constrained-step-up-bab.csv};
            \addlegendimage{color=orange, mark=triangle}

            \addlegendimage{color=white, only marks}
            % \addplot[color=teal, mark=o] table {./results/known/occurrence-step-down-bab.csv};
            \addlegendimage{color=teal, mark=o}
            % \addplot[color=teal, mark=square] table {./results/known/occurrence-step-median-bab.csv};
            \addlegendimage{color=teal, mark=square}
            \addplot[color=teal, mark=diamond] table {./results/known/occurrence-step-middle-bab.csv};
            % \addplot[color=teal, mark=triangle] table {./results/known/occurrence-step-up-bab.csv};
            \addlegendimage{color=teal, mark=triangle}

            \addlegendimage{color=white, only marks}
            \addplot[color=violet, mark=o] table {./results/known/smallest-step-down-bab.csv};
            \addplot[color=violet, mark=square] table {./results/known/smallest-step-median-bab.csv};
            \addplot[color=violet, mark=diamond] table {./results/known/smallest-step-middle-bab.csv};
            % \addplot[color=violet, mark=triangle] table {./results/known/smallest-step-up-bab.csv};
            \addlegendimage{color=violet, mark=triangle}

            \legend{
                anti\_first\_fail:, down, median, middle, up,
                dom\_w\_deg:, down, median, middle, up,
                first\_fail:, down, median, middle, up,
                impact:, down, median, middle, up,
                largest:, down, median, middle, up,
                leftmost:, down, median, middle, up,
                max\_regret:, down, median, middle, up,
                most\_constrained:, down, median, middle, up,
                occurrence:, down, median, middle, up,
                smallest:, down, median, middle, up,
            }
        \end{semilogxaxis}
    \end{tikzpicture}
\end{center}

\begin{center}
    \begin{tikzpicture}
        \begin{semilogxaxis}[title=Global Constraints Comparison - Score over time with "empty" input]
            \addplot[color=blue, mark=o] table {./results/old.csv};
            \addplot[color=red, mark=o] table {./results/empty/impact-step-down-bab.csv};

            \legend{
                Before global constraints,
                After global constraints,
            }
        \end{semilogxaxis}
    \end{tikzpicture}
\end{center}

\end{document}
